/**
 * Displays the 3D model of the board and host the array of pawns
 * @constructor
 * @param {array} gameBoard - the board object as generated by the server
 * @param {object} render - render reference
 */
class Board {
    constructor(gameBoard, render) {

        this.squareSize = render.squareSize
        this.nbRows = gameBoard.nbRows;
        this.nbColumns = gameBoard.nbColumns;
        this.pawns = gameBoard.pawns;

        //Construct the board 
        var squareMaterial;
        for (var row = 0; row < this.nbRows; row++) {
            for (var col = 0; col < this.nbColumns; col++) {
                if ((row + col) % 2 === 0) { // light square
                    squareMaterial = render.materials.lightSquareMaterial;
                } else { // dark square
                    squareMaterial = render.materials.darkSquareMaterial;
                }
                var square = new THREE.Mesh(new THREE.PlaneGeometry(this.squareSize, this.squareSize, 1, 1), squareMaterial);
                square.position.x = col * this.squareSize + this.squareSize / 2;
                square.position.z = row * this.squareSize + this.squareSize / 2;
                square.position.y = -0.01;
                square.rotation.x = -90 * Math.PI / 180;
                render.scene.add(square);
            }
        }

        render.centerCamera([this.nbRows/2, this.nbColumns/2])

        render.boardModel = new THREE.Mesh(render.objects.board, render.materials.boardMaterial);
        render.boardModel.position.y = -0.02;

        // add ground
        render.groundModel = new THREE.Mesh(new THREE.PlaneGeometry(100, 100, 1, 1), render.materials.groundMaterial);
        render.groundModel.position.set(this.squareSize * 4, -1.52, this.squareSize * 4);
        render.groundModel.rotation.x = -90 * Math.PI / 180;
        render.scene.add(render.groundModel);
    }

    /**
     * Convert 3D coordinates to a cell on the board
     * @param  {object} pos - coordinates of a point in he 3D world
     * @return {bool | array} - false if the coordinates don't match a cell on the board, an array of the positions of the cell if else
     */
    worldToBoard(pos) {
        var i = this.nbRows - Math.ceil((this.squareSize * this.nbRows - pos.z) / this.squareSize);
        var j = Math.ceil(pos.x / this.squareSize) - 1;
        if (i >= this.nbRows || i < 0 || j >= this.nbColumns || j < 0 || isNaN(i) || isNaN(j)) {
            return false;
        }
        return [i, j];
    }

    /**
     * Convert a cell on the board to 3D coordinates
     * @param  {array} pos - array of the position of the cell
     * @return {object} - a three.js vector
     */
    boardToWorld (pos) {
        var x = (1 + pos[1]) * this.squareSize - this.squareSize / 2;
        var z = (1 + pos[0]) * this.squareSize - this.squareSize / 2;
        return new THREE.Vector3(x, 0, z);
    }
}